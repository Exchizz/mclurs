--- 4.6.3-usbduxfast.c	2016-07-01 12:41:32.840558437 +0200
+++ usbduxfast_4.6.3_john.c	2016-08-04 10:54:41.819434106 +0200
@@ -29,6 +29,8 @@
  *
  * Bernd Porr
  *
+ * Various revisions made to allow full-rate sampling of 16 channels,
+ * copyright (C) 2014 John Hallam (JCTH)
  *
  * Revision history:
  * 0.9: Dropping the first data packet which seems to be from the last transfer.
@@ -100,9 +102,11 @@
 #define SIZEADIN	(sizeof(s16))
 
 /*
- * size of the input-buffer IN BYTES
+ * size of the input-buffer IN USB Bulk Packet Buffers (512)
+ * -- the default for the urbsz module parameter.
  */
-#define SIZEINBUF	512
+#define URBSZINBUF	8
+#define MAX_URBSZINBUF	16	/* Limit max buffer size for kernel's sake! */
 
 /*
  * 16 bytes
@@ -115,9 +119,10 @@
 #define SIZEOFDUXBUF	256
 
 /*
- * number of in-URBs which receive the data: min=5
+ * number of in-URBs which receive the data: MAX and DEFAULT
  */
-#define NUMOFINBUFFERSHIGH	10
+#define MAX_NUM_URBS	 8
+#define DEFAULT_NUM_URBS 4
 
 /*
  * min delay steps for more than one channel
@@ -133,6 +138,18 @@
 #define MAX_SAMPLING_PERIOD	500
 
 /*
+ * Convert FX2 GPIF ticks to nanoseconds and vice versa by integer arithmetic.
+ *
+ * NS_TO_TICKS quantizes the requested delay into 30 MHz clock ticks.
+ * TICKS_TO_NS computes the inter-channel delay given the sampling loop length in ticks.
+ *
+ * It is important that NS_TO_TICKS(TICKS_TO_NS(.)) is the identity function.
+ * N.B. Avoid side-effects in the arguments to these macros.
+ */
+#define NS_TO_TICKS(ns) ((30*(ns)+500)/1000)
+#define TICKS_TO_NS(nt)	(100*((nt)/3) + 33*((nt)%3) + (((nt)%3) == 2))
+
+/*
  * number of received packets to ignore before we start handing data
  * over to comedi, it's quad buffering and we have to ignore 4 packets
  */
@@ -155,15 +172,44 @@
  * one sub device just now: A/D
  */
 struct usbduxfast_private {
-	struct urb *urb;	/* BULK-transfer handling: urb */
+	struct urb *urb[MAX_NUM_URBS];	/* BULK-transfer handling: urb */
+	s8 *inbuf[MAX_NUM_URBS];
+	s8 *insnbuf;
 	u8 *duxbuf;
-	s8 *inbuf;
 	short int ai_cmd_running;	/* asynchronous command is running */
 	int ignore;		/* counter which ignores the first buffers */
 	struct mutex mut;
 };
 
 /*
+ * Maximum usable number of URBs:  is MAX_NUM_URBS rounded to even.
+ */
+static const int max_num_urbs = (MAX_NUM_URBS&~1);
+
+/*
+ * Number of URBs allocated per (sub)device.  Default is DEFAULT_NUM_URBS.
+ * Instantiated by the probe function.
+ */
+static int nurbs = 0;
+module_param(nurbs, int, S_IRUGO);
+MODULE_PARM_DESC(nurbs, "Number of InURBs to allocate (default 4)");
+
+/*
+ * Are the URBs paired or not?
+ */
+static int paired = 1;
+module_param(paired, int, S_IRUGO);
+MODULE_PARM_DESC(paired, "Use InURBs in pairs if non-zero (default 1);  implies nurbs is even");
+
+/*
+ * URB request buffer size, as a multiple of 512 bytes
+ * The default is set in the probe function from URBSZINBUFUSB
+ */
+static int urbsz = 0;
+module_param(urbsz, int, S_IRUGO);
+MODULE_PARM_DESC(urbsz, "Size of transfer requested by an InURBs in USB bulk packets (default 8)");
+
+/*
  * bulk transfers to usbduxfast
  */
 #define SENDADCOMMANDS            0
@@ -228,6 +274,20 @@
 	return ret;
 }
 
+/*
+ * Paired URB helper function -- assumes not too many URBs.
+ */
+static struct urb *paired_urb(struct usbduxfast_private *udfp, struct urb *urb)
+{
+  int i;
+
+  for(i=0; i<max_num_urbs; i++) {
+    if( udfp->urb[i] == urb )
+      return udfp->urb[i^1];
+  }
+  return NULL;
+}
+
 static void usbduxfast_ai_handle_urb(struct comedi_device *dev,
 				     struct comedi_subdevice *s,
 				     struct urb *urb)
@@ -237,6 +297,31 @@
 	struct comedi_cmd *cmd = &async->cmd;
 	int ret;
 
+	/*
+	 * If pairing and command still running, submit the paired urb now, if not resubmit this one at end
+	 */
+	if (paired && !(async->events & COMEDI_CB_CANCEL_MASK)) {
+	  struct urb *next_urb = paired_urb(devpriv, urb);
+	  int err = 0;
+	  
+	  if (next_urb) {
+	    next_urb->dev = comedi_to_usb_dev(dev);
+	    next_urb->status = 0;
+	    err = usb_submit_urb(next_urb, GFP_ATOMIC);
+	  }
+	  if (!next_urb || err < 0) {
+	    /*
+	     * Fixme: This throws away a valid URB (the current one) if pair submission fails
+	     */
+	    dev_err(dev->class_dev, "paired urb submit failed: %d", err);
+	    async->events |= COMEDI_CB_EOA;
+	    async->events |= COMEDI_CB_ERROR;
+	    comedi_event(dev, s);
+	    usbduxfast_ai_stop(dev, 0);
+	    return;
+	  }
+	}
+
 	if (devpriv->ignore) {
 		devpriv->ignore--;
 	} else {
@@ -252,12 +337,12 @@
 	}
 
 	/* if command is still running, resubmit urb for BULK transfer */
-	if (!(async->events & COMEDI_CB_CANCEL_MASK)) {
+	if (!(async->events & COMEDI_CB_CANCEL_MASK) && !paired) {
 		urb->dev = comedi_to_usb_dev(dev);
 		urb->status = 0;
 		ret = usb_submit_urb(urb, GFP_ATOMIC);
 		if (ret < 0) {
-			dev_err(dev->class_dev, "urb resubm failed: %d", ret);
+			dev_err(dev->class_dev, "urb resubmit failed: %d", ret);
 			async->events |= COMEDI_CB_ERROR;
 		}
 	}
@@ -310,17 +395,24 @@
 {
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxfast_private *devpriv = dev->private;
-	int ret;
+	const int InURB_buf_size = 512 * urbsz;
+	int j, ret;
 
-	usb_fill_bulk_urb(devpriv->urb, usb, usb_rcvbulkpipe(usb, BULKINEP),
-			  devpriv->inbuf, SIZEINBUF,
-			  usbduxfast_ai_interrupt, dev);
-
-	ret = usb_submit_urb(devpriv->urb, GFP_ATOMIC);
-	if (ret) {
-		dev_err(dev->class_dev, "usb_submit_urb error %d\n", ret);
-		return ret;
+	for(j=0; j<nurbs && devpriv->urb[j]; j++) {
+	  usb_fill_bulk_urb(devpriv->urb[j], usb, usb_rcvbulkpipe(usb, BULKINEP),
+			    devpriv->inbuf[j], InURB_buf_size,
+			    usbduxfast_ai_interrupt, dev);
+	}
+
+	for(j=0; j<nurbs && devpriv->urb[j]; j++) {
+	  ret = usb_submit_urb(devpriv->urb[j], GFP_ATOMIC);
+	  if (ret) {
+	    dev_err(dev->class_dev, "usb_submit_urb[%d] error %d\n", j, ret);
+	    return ret;
+	  }
+	  if (paired) j++;	/* Only submit the first of each pair now */
 	}
+
 	return 0;
 }
 
@@ -406,12 +498,13 @@
 	 * for all other chanlist_len it is:
 	 *	MIN_SAMPLING_PERIOD <= steps <= MAX_SAMPLING_PERIOD
 	 */
-	steps = (cmd->convert_arg * 30) / 1000;
+	steps = NS_TO_TICKS(cmd->convert_arg);
 	if (cmd->chanlist_len !=  1)
 		err |= comedi_check_trigger_arg_min(&steps,
 						    MIN_SAMPLING_PERIOD);
 	err |= comedi_check_trigger_arg_max(&steps, MAX_SAMPLING_PERIOD);
-	arg = (steps * 1000) / 30;
+	/* calc arg again -- correct for tick quantisation */
+	arg = TICKS_TO_NS(steps);
 	err |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);
 
 	if (cmd->stop_src == TRIG_COUNT)
@@ -468,8 +561,8 @@
 {
 	struct usbduxfast_private *devpriv = dev->private;
 	struct comedi_cmd *cmd = &s->async->cmd;
-	unsigned int rngmask = 0xff;
-	int j, ret;
+	unsigned int chan, gain, rngmask = 0xff;
+	int i, j, ret, result;
 	long steps, steps_tmp;
 
 	mutex_lock(&devpriv->mut);
@@ -484,7 +577,7 @@
 	 */
 	devpriv->ignore = PACKETS_TO_IGNORE;
 
-	steps = (cmd->convert_arg * 30) / 1000;
+	steps = NS_TO_TICKS(cmd->convert_arg);
 
 	switch (cmd->chanlist_len) {
 	case 1:
@@ -681,52 +774,60 @@
 		break;
 
 	case 16:
-		if (CR_RANGE(cmd->chanlist[0]) > 0)
-			rngmask = 0xff - 0x04;
-		else
-			rngmask = 0xff;
+		if (cmd->start_src == TRIG_EXT) {	     /* Trigger on RDY0 state */
 
-		if (cmd->start_src == TRIG_EXT) {
-			/*
-			 * we loop here until ready has been set
-			 */
+		        if( cmd->chanlist[0] & CR_INVERT ) { /* Trigger is active low */
 
-			/* branch back to state 0 */
-			/* deceision state w/o data */
-			/* reset */
-			/* RDY0 = 0 */
-			usbduxfast_cmd_data(dev, 0, 0x01, 0x01,
-					    (0xff - 0x02) & rngmask, 0x00);
+			  /* State 0 */
+			  /* branch back to state 0 while RDY0 = 1 */
+			  /* decision state w/o data */
+			  /* reset CTL1 is low while waiting, min 33ns */
+			  usbduxfast_cmd_data(dev, 0, 0x10, 0x01,
+					      (0xff - 0x02) & rngmask, 0x00);
+
+			} else {			     /* Trigger is active high */
+
+			  /* State 0 */
+			  /* branch back to state 0 while RDY0 = 0 */
+			  /* decision state w/o data */
+			  /* reset CTL1 is low while waiting, min 33ns */
+			  usbduxfast_cmd_data(dev, 0, 0x02, 0x01,
+					      (0xff - 0x02) & rngmask, 0x00);
+			}
 		} else {
-			/*
-			 * we just proceed to state 1
-			 */
-
-			/* 30us reset pulse */
-			/* reset */
-			usbduxfast_cmd_data(dev, 0, 0xff, 0x00,
-					    (0xff - 0x02) & rngmask, 0x00);
+			  /* State 0 */
+			  /* branch to state 2 unconditionally */ 
+			  /* 33ns reset pulse */
+			  /* reset CTL1 is low */
+			  usbduxfast_cmd_data(dev, 0, 0x12, 0x01,
+					      (0xff - 0x02) & rngmask, 0x00);
 		}
 
+		/* State 1 */
 		/* commit data to the FIFO */
-		/* data */
-		usbduxfast_cmd_data(dev, 1, 0x01, 0x02, rngmask, 0x00);
+		/* data to FIFO */
+		/* muxclock CTL0 goes high */
+		usbduxfast_cmd_data(dev, 1, 0x01, 0x02, 0xff & rngmask, 0x00);
 
 		/* we have 2 states with duration 1 */
 		steps = steps - 2;
 
+		/* State 2 */
 		/* do the first part of the delay */
 		usbduxfast_cmd_data(dev, 2, steps / 2,
-				    0x00, 0xfe & rngmask, 0x00);
+				    0x00, 0xff & rngmask, 0x00);
 
+		/* State 3 */
 		/* and the second part */
 		usbduxfast_cmd_data(dev, 3, steps - steps / 2,
-				    0x00, rngmask, 0x00);
+				    0x00, 0xff & rngmask, 0x00);
 
+		/* State 4 */
 		/* branch back to state 1 */
-		/* deceision state w/o data */
-		/* doesn't matter */
-		usbduxfast_cmd_data(dev, 4, 0x09, 0x01, rngmask, 0xff);
+		/* decision state w/o data */
+		/* muxclock CTL0 goes low */
+		usbduxfast_cmd_data(dev, 4, 0x09, 0x01,
+				    (0xff - 0x01) & rngmask, 0xff);
 
 		break;
 	}
@@ -805,7 +906,7 @@
 
 	for (i = 0; i < PACKETS_TO_IGNORE; i++) {
 		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),
-				   devpriv->inbuf, SIZEINBUF,
+				   devpriv->insnbuf, SIZEINSNBUF,
 				   &actual_length, 10000);
 		if (ret < 0) {
 			dev_err(dev->class_dev, "insn timeout, no data\n");
@@ -816,7 +917,7 @@
 
 	for (i = 0; i < insn->n;) {
 		ret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),
-				   devpriv->inbuf, SIZEINBUF,
+				   devpriv->insnbuf, SIZEINSNBUF,
 				   &actual_length, 10000);
 		if (ret < 0) {
 			dev_err(dev->class_dev, "insn data error: %d\n", ret);
@@ -830,7 +931,7 @@
 			return -EINVAL;
 		}
 		for (j = chan; (j < n) && (i < insn->n); j = j + 16) {
-			data[i] = ((u16 *)(devpriv->inbuf))[j];
+			data[i] = ((u16 *)(devpriv->insnbuf))[j];
 			i++;
 		}
 	}
@@ -918,7 +1019,8 @@
 	struct usb_device *usb = comedi_to_usb_dev(dev);
 	struct usbduxfast_private *devpriv;
 	struct comedi_subdevice *s;
-	int ret;
+	const  int InURB_buf_size = 512 * urbsz;
+	int j, ret;
 
 	if (usb->speed != USB_SPEED_HIGH) {
 		dev_err(dev->class_dev,
@@ -945,15 +1047,23 @@
 		return -ENODEV;
 	}
 
-	devpriv->urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (!devpriv->urb) {
-		dev_err(dev->class_dev, "Could not alloc. urb\n");
-		return -ENOMEM;
-	}
-
-	devpriv->inbuf = kmalloc(SIZEINBUF, GFP_KERNEL);
-	if (!devpriv->inbuf)
-		return -ENOMEM;
+	for(j=0; j<nurbs; j++) {
+	  devpriv->urb[j] = usb_alloc_urb(0, GFP_KERNEL);
+	  if (!devpriv->urb[j]) {
+	    dev_err(dev->class_dev, "Could not alloc. urb[%d]\n", j);
+	    return -ENOMEM;
+	  }
+	}
+
+	for(j=0; j<nurbs; j++) {
+	  devpriv->inbuf[j] = kmalloc(InURB_buf_size, GFP_KERNEL);
+	  if (!devpriv->inbuf[j])
+	    return -ENOMEM;
+	}
+
+	devpriv->insnbuf = kmalloc(SIZEINSNBUF, GFP_KERNEL);
+	if (!devpriv->insnbuf)
+	  return -ENOMEM;
 
 	ret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,
 				   usbduxfast_upload_firmware, 0);
@@ -993,14 +1103,26 @@
 
 	usb_set_intfdata(intf, NULL);
 
-	if (devpriv->urb) {
-		/* waits until a running transfer is over */
-		usb_kill_urb(devpriv->urb);
+	if (devpriv->urb[0]) {
+	  int j;
 
-		kfree(devpriv->inbuf);
-		usb_free_urb(devpriv->urb);
+	  /* waits until a running transfer is over */
+	  for(j=0; j<nurbs && devpriv->urb[j]; j++)
+	    usb_kill_urb(devpriv->urb[j]);
+
+	  for(j=0; j<nurbs && devpriv->urb[j]; j++) {
+	    if( devpriv->inbuf[j] )
+	      kfree(devpriv->inbuf[j]);
+	    devpriv->inbuf[j] = NULL;
+
+	    if( devpriv->urb[j] )
+	      usb_free_urb(devpriv->urb[j]);
+	    devpriv->urb[j] = NULL;
+	  }
 	}
 
+	kfree(devpriv->insnbuf);
+	
 	kfree(devpriv->duxbuf);
 
 	mutex_unlock(&devpriv->mut);
@@ -1016,6 +1138,31 @@
 static int usbduxfast_usb_probe(struct usb_interface *intf,
 				const struct usb_device_id *id)
 {
+	if (nurbs <= 0) {
+	  nurbs = DEFAULT_NUM_URBS;
+	}
+
+	if (paired) {
+	  nurbs = (nurbs+1) & ~1; /* Make even, rounding up */
+	}
+
+	if (nurbs > max_num_urbs) {
+	  printk(KERN_WARNING "usbduxfast module: nurbs %d exceeds compiled maximum %d\n", nurbs, max_num_urbs);
+	  nurbs = max_num_urbs;
+	}
+
+	if (urbsz <= 0) {
+	  urbsz = URBSZINBUF;
+	}
+
+	if (urbsz > MAX_URBSZINBUF) {
+	  printk(KERN_WARNING "usbduxfast module: urbsz %d exceeds compiled maximum %d\n", urbsz, MAX_URBSZINBUF);
+	  urbsz = URBSZINBUF;
+	}
+
+	printk(KERN_INFO "usbduxfast module: using %d %s URB(s) of size %d*512 bytes for bulk transfer\n",
+	       nurbs, (paired? "paired" : ""), urbsz); 
+
 	return comedi_usb_auto_config(intf, &usbduxfast_driver, 0);
 }
 
@@ -1035,7 +1182,7 @@
 };
 module_comedi_usb_driver(usbduxfast_driver, usbduxfast_usb_driver);
 
-MODULE_AUTHOR("Bernd Porr, BerndPorr@f2s.com");
-MODULE_DESCRIPTION("USB-DUXfast, BerndPorr@f2s.com");
+MODULE_AUTHOR("Bernd Porr, BerndPorr@f2s.com, John Hallam sw@j.hallam.dk");
+MODULE_DESCRIPTION("USB-DUXfast, BerndPorr@f2s.com, John Hallam sw@j.hallam.dk");
 MODULE_LICENSE("GPL");
 MODULE_FIRMWARE(FIRMWARE);
